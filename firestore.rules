
/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model for writes,
 * but allows for public readability of shared content like communities and profiles.
 * This supports discoverability while maintaining security.
 *
 * Data Structure:
 * - `/users/{userId}`: Strictly private user account data.
 *   - `/users/{userId}/stories/{storyId}`: Stories are nested and private to the user.
 *   - `/users/{userId}/assets/{assetId}`: Assets are nested and private to the user.
 * - `/community-profiles/{userId}`: Publicly readable profiles, writable only by the owner.
 * - `/communities/{communityId}`: Publicly readable communities, writable only by the owner.
 *   - `/communities/{communityId}/forms/{formId}`: Forms are readable by any signed-in user.
 *   - `/communities/{communityId}/creations/{creationId}`: Creations are private to community members.
 *   - `/communities/{communityId}/roadmap/{columnId}`: Roadmap is private to community members.
 * - `/_private_admin_data/{docId}`: Highly restricted data, only accessible by the founder.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //================================================================================
    // Helper Functions
    //================================================================================

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isFounder() {
      return isSignedIn() && request.auth.token.email == 'gg.el0ai.com@gmail.com';
    }
    
    // --- User Validation Functions ---
    function hasValidUserData(userId) {
      return request.resource.data.id == userId;
    }

    function isImmutableUserId() {
      return request.resource.data.id == resource.data.id;
    }
    
    // --- Community Validation Functions ---
    function hasValidCommunityData() {
        return request.resource.data.ownerId == request.auth.uid;
    }
    
    function isCommunityOwner(communityId) {
        return get(/databases/$(database)/documents/communities/$(communityId)).data.ownerId == request.auth.uid;
    }
    
    function isCommunityMember(communityId) {
      // This function can only be used for GET, not LIST operations.
      // `exists` is used here which is more efficient.
      let community = get(/databases/$(database)/documents/communities/$(communityId));
      return exists(/databases/$(database)/documents/communities/$(communityId)) &&
             (community.data.ownerId == request.auth.uid || 
              (community.data.members != null && request.auth.uid in community.data.members));
    }

    function isModifyingOwnMembership() {
      // Check if the update is only removing the current user from the members list
      let userIsBeingRemoved = !request.auth.uid in request.resource.data.members.map(m => m.userId) &&
                                request.auth.uid in resource.data.members.map(m => m.userId);
      let listIsSmallerByOne = request.resource.data.members.size() == resource.data.members.size() - 1;
      
      return userIsBeingRemoved && listIsSmallerByOne;
    }
    
    // --- Community Profile Validation ---
    function hasValidProfileData(userId) {
        return request.resource.data.userId == userId && request.resource.data.id == userId;
    }

    function isImmutableProfileIds() {
        return request.resource.data.id == resource.data.id && request.resource.data.userId == resource.data.userId;
    }

    // --- Subcollection Validation ---
    function hasValidSubcollectionData(userId) {
        let incomingData = request.resource.data;
        return incomingData.userId == userId || incomingData.ownerId == userId;
    }
    
    // --- Join Request Validation ---
    function isValidJoinRequest() {
        let incomingData = request.resource.data;
        return incomingData.userId == request.auth.uid
            && incomingData.status == 'pending';
    }
    
    // --- Fabrication Order Validation ---
    function isValidFabricationOrder() {
        let incomingData = request.resource.data;
        return incomingData.userId == request.auth.uid
            && incomingData.status == 'pending';
    }
    
    function isSupplier() {
      // In a real app, this would check for a custom claim.
      // For now, we'll keep it simple and check for a specific email.
      return isFounder();
    }
    
    // --- Bug Report Validation ---
    function isValidBugReport() {
        let d = request.resource.data;
        return d.reporterId == request.auth.uid
            && d.status == 'new'
            && d.title is string && d.title.size() > 4
            && d.description is string && d.description.size() > 19;
    }

    // --- Creation Validation ---
    function isValidCreation() {
        let d = request.resource.data;
        return d.creatorId == request.auth.uid
            && d.prompt is string && d.prompt.size() > 2
            && d.pixels is list && d.pixels.size() > 0
            && d.status == 'in-workshop'; // Creations must start in the workshop
    }
    
    // --- Event Validation ---
    function isEventOrganizer(eventId) {
        return get(/databases/$(database)/documents/events/$(eventId)).data.organizerId == request.auth.uid;
    }


    //================================================================================
    // Collection Rules
    //================================================================================

    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidUserData(userId);
      allow update: if isOwner(userId) && isImmutableUserId();
      allow delete: if isOwner(userId);

        /**
         * @description Manages AI-generated stories for a specific user.
         * @path /users/{userId}/stories/{storyId}
         * @allow A user can perform any action on their own stories.
         */
        match /stories/{storyId} {
            allow read, write: if isOwner(userId);
        }
        
        /**
         * @description Manages snapshots of a user's story history.
         * @path /users/{userId}/historySnapshots/{snapshotId}
         * @allow A user can perform any action on their own history snapshots.
         */
        match /historySnapshots/{snapshotId} {
            allow read, write, delete: if isOwner(userId);
        }

        /**
         * @description Manages personal assets for a specific user.
         * @path /users/{userId}/assets/{assetId}
         * @allow A user can perform any action on their own assets.
         */
        match /assets/{assetId} {
            allow read, write: if isOwner(userId);
        }
    }

     /**
     * @description Manages user community profiles.
     * @path /community-profiles/{userId}
     * @allow Anyone can read a profile, but only the owner can create/update/delete it.
     */
    match /community-profiles/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if isOwner(userId) && hasValidProfileData(userId);
        allow update: if isOwner(userId) && isImmutableProfileIds();
        allow delete: if isOwner(userId);
    }
    
    /**
     * @description Manages all communities.
     * @path /communities/{communityId}
     * @allow Anyone can read/list communities. Only the owner can create, update, or delete.
     * Members can update the `members` field to remove themselves.
     * The owner can update any field, including removing other members.
     */
    match /communities/{communityId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && hasValidCommunityData();
        allow update: if isCommunityOwner(communityId) || isModifyingOwnMembership();
        allow delete: if isCommunityOwner(communityId);

        /**
         * @description Manages forms (conversation starters) within a community.
         * @path /communities/{communityId}/forms/{formId}
         * @allow Read is public. Create is for any signed-in user. Update is for author or community owner (for soft delete/moderation). Hard delete is disallowed.
         */
        match /forms/{formId} {
            allow read: if isSignedIn();
            allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
            allow update: if isCommunityOwner(communityId) || request.auth.uid == resource.data.userId;
            allow delete: if false;

             /**
             * @description Manages comments on a specific form.
             * @path /communities/{communityId}/forms/{formId}/comments/{commentId}
             * @allow Read is public. Create is for any signed-in user. Update is for author or community owner. Hard delete is disallowed.
             */
            match /comments/{commentId} {
                allow read: if isSignedIn();
                allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
                allow update: if isCommunityOwner(communityId) || request.auth.uid == resource.data.userId;
                allow delete: if false;
            }
        }
        
        /**
         * @description Manages requests from users to join a community.
         * @path /communities/{communityId}/joinRequests/{requestId}
         */
        match /joinRequests/{requestId} {
            allow get: if isSignedIn() && (isCommunityOwner(communityId) || request.auth.uid == requestId);
            allow list: if isCommunityOwner(communityId);
            allow create: if isOwner(requestId) && isValidJoinRequest();
            allow update, delete: if isCommunityOwner(communityId);
        }

        /**
         * @description Stores generative artworks. Published works are public. Workshop items are for members only.
         * @path /communities/{communityId}/creations/{creationId}
         */
        match /creations/{creationId} {
            allow get: if resource.data.status == 'published' || isSignedIn();
            allow list: if isSignedIn(); // Allow any signed-in user to list creations, client-side filters members.
            allow create: if isSignedIn() && isValidCreation();
            allow update: if isCommunityOwner(communityId); // Only owner can publish or moderate
            allow delete: if isCommunityOwner(communityId);
        }
        
        /**
         * @description Manages the private roadmap for a specific community.
         * @path /communities/{communityId}/roadmap/{columnId}
         */
        match /roadmap/{columnId} {
            // Read access is controlled on the client by checking for membership
            allow get, list: if isSignedIn();
            allow write: if isCommunityOwner(communityId);
        }
    }
    
    /**
     * @description Manages fabrication orders (tickets).
     * @path /fabricationOrders/{orderId}
     */
    match /fabricationOrders/{orderId} {
      allow get, list: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow create: if isSignedIn() && isValidFabricationOrder();
      allow update: if isSupplier() && !('userId' in request.resource.data); // Supplier can update status, cost, etc.
      allow delete: if isOwner(resource.data.userId); // User can cancel their own order.
    }
    
    /**
     * @description Manages the public project roadmap.
     * @path /roadmap/{columnId}
     * @allow Public read access for all, write access restricted to the founder.
     */
    match /roadmap/{columnId} {
        allow get, list: if true;
        allow write: if isFounder();
    }
    
    /**
     * @description Manages bug reports.
     * @path /bugs/{bugId}
     * @allow Publicly readable. Any signed-in user can create a new bug report.
     */
    match /bugs/{bugId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isValidBugReport();
      allow update, delete: if isFounder();
    }
    
    /**
     * @description Stores conversation history with the Ambasedor SuperAgent.
     * @path /ambasedor/{userId}
     * @allow Users can only read and write to their own conversation history.
     */
    match /ambasedor/{userId} {
        allow read, write: if isOwner(userId);
    }

    /**
     * @description Publicly readable leaderboard. Writes are restricted to server-side actions.
     * @path /leaderboard/{userId}
     */
    match /leaderboard/{userId} {
        allow get, list: if true;
        allow write: if false; // Disallow all client-side writes.
    }
    
    /**
     * @description Manages social events.
     * @path /events/{eventId}
     */
    match /events/{eventId} {
        allow read: if true;
        allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
        allow update: if isSignedIn() && (isEventOrganizer(eventId) || request.resource.data.attendees.hasOnly(request.auth.uid));
        allow delete: if isSignedIn() && isEventOrganizer(eventId);
    }

    /**
     * @description Tracks user online status. Publicly readable, only writable by the user themselves.
     * @path /presence/{userId}
     */
    match /presence/{userId} {
      allow read: if true;
      allow write: if isOwner(userId);
    }


    /**
     * @description Secure storage for administrative data, like service account keys.
     * @path /_private_admin_data/{docId}
     * @allow Only the founder can read or write to this collection.
     */
    match /_private_admin_data/{docId} {
        allow read, write: if isFounder();
        allow list: if false; // Disallow listing documents for security.
    }
  }
}
